
Group members, Yan Zhen Lin, Cameron Rivera, Gabriella Voll, Sidney Thelusma, Vladislav Mayzlin
Assignment 5
File: Graph traversal implementation using Dijkstra's algorithm

Assignmnet5
Graph traversal with Dijkstra's Algorithm

	The goal of this project is to find the shortest path length from an arbitrary initial vertex to every other reachable vertex in the Graph. The graph is both weighted and directed with at most one distinct edge going from any given vertex to any other one; this means that starting from vertex A, there is but one edge that goes directly from it to vertex B. The program will run based off an input text file containing the data necessary to build the Graph, as well as a input flag, which will denote the starting vertex in the graph. The program will display a list of all of the vertices in the Graph as well as the shortest path length from an initial vertex each respective vertex in the graph.
	The Text file is called Graph1.txt. The first line of the text file should contain a single interger denoting the number of vertices in the graph. The remaining lines in the file denote the data for each vertex. Each line begins with the name of the vertex. If this vertex contains adjacent vertices, then the remainder of the line will alternate between adjacent vertex name and the weight of the edge going from the vertex to its adjacent vertex. The number of Adjacent vertices can be up to N-1, where N is the total number of vertices in the Graph. The end of the list of adjacent vertices is denoted by a -1 interger value. The program will treat each line as a vertex, hence if the text data for a single vertex extends to more than one line, this will create issues in the program, which will result in an inaccurate graph. Also, the parse will be thrown off if the text file is not in the correct format. That is, every distinct data member is separated by a space character.
	The program runs in two parts. The first part builds the graph from the text file passed in as an argument to the main function. The second part is our implementation of Dikjstras' algorithm. Building the Graph required us to instantiate a Graph class with a set number of vertices. The graph class contains a dynamically allocated array that holds each vertex in the graph. In addition to the array of vertices, the Graph contains, a size data member that is used in the dynamic allocation and a Stack to keep track of our graph traversal. Each cell in the array contains an individual vertex object. Each vertex in the graph contains a binaryHeap data member that takes a pair composed of an adjacent vertex name as its first value and the weight associated with it as its second value. The binaryHeap is a minimum heap with the weight of each adjacent vertex used as the key value. Each call to deleteMin deletes the adjacent vertex with the lowest cost and places the adjacent vertex with the next lowest cost in the first position. In addition to the binaryheap data member, the vertex class contains a float value that contains the shortest path length from the initial vertex to it (initially set to infinity), and a comparable value to hold the name of the previous vertex in the path (initially set to 0). To build the Graph in main file, we first instantiate the graph class and the create a new vertex object to contain the date read in from a line. Once we get the data, we take the corresponding vertex item in the Graph's array data member and set it equal to the vertex we've just built using the operator equals overload in the vertex class. We do this for every Vertex in the text file. Our implementation of a graph is an adjacency list.
	After building our graph, we perform Dijkstra's algorithm using a greedy implementation. We start by setting an inital vertex's, obtained from an argument passed into the main function, minimum distance to 0 (from infinity). We also set its previous path value to itself. We then examine the inital vertex's binaryHeap and, if not empty, read the first value in it and save it to in a temporary value. We then perform a deleteMin on the heap. After which we check to see if the heap is empty, if not and the intial vertex is not already on the graph stack member, we push it on the stack. We then search for the vertex in the array based on the name obtained from the first data member in the pair we deleted from the heap; this is done using a search function. The search fucntion takes the name of the "target vertex" as a parameter and searches the array for it. It then returns that vertex by reference. We then traverse to the "target vertex" using a float parameter that is the sum of the second item from the pair obtained from the binary heap, and the current vertex's minimum distance value, which will call package X. In addition to package x, we pass in a vertex name that is used to update the target vertex's previous vertex member. Then we compare  with the target vertex's minimum distance. If the value of package x is less than the target vertex's minimum distance, we set the value of the target vertex's minimum distance equal to the value of package x. If the target vertex's minimum distance was changed, we set target vertex's previous vertex equal to the name of the vertex that was previously read. We recursively perform the above steps to the target vertex. If, at any time during the traversal we encounter an empty heap, we peek at the top at the stack. If the stack is not empty, we perform the traversal on the item at the top of the stack. If the stack is empty, it means that all paths have been traversed. Our implementation of runs with a theoretical runtime of O(|E|log|V|).
	The program prompts the user for a target vertex. The program will then output the shortest path length from the initial vertex to that vertex in addition to its path. The END.


git test starts here
